"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const rand_1 = require("../../../random/rand");
const lodash_1 = __importDefault(require("lodash"));
const extractor_1 = require("../extractor/extractor");
const extractor_2 = require("../extractor/extractor");
/**
 * @brief _Genode - class for AST node generation from a set of nodes
 */
class _Genode {
    /**
     * @brief constructor
     *
     * @param {Array|String} types - accepted types, only these will remain in the provided node set
     */
    constructor(types) {
        this._sim = class _sim {
            /**
             * @brief constructor - deep copies a sample provided and stores it in the object
             *
             * @param {Node} sample - a node sample
             */
            constructor(sample) {
                this._sample = lodash_1.default.cloneDeep(sample);
            }
            /**
             * @brief using - method which will generate the new AST node
             * by the sample provided to the constructor
             *
             * @param {Array<Node>} nodes - generate new AST node using these nodes
             */
            using(nodes) {
                if (nodes instanceof Array && nodes.length > 0) {
                    const gentype = _sim._parent._types;
                    // create and use the extractor
                    let extracted = extractor_1._extract(gentype).from(this._sample);
                    for (let i = 0; i < extracted.length; ++i) {
                        let extr = extracted[i];
                        // filter all nodes by type of current extraction value type
                        let candidates = nodes.filter(value => value.type === extr.type);
                        // concat the extracted value, too since the type of it, too
                        // satisfies the criteria
                        candidates = candidates.concat(extr);
                        // change the inner sample by changing the reference
                        // to its nodes
                        const index = rand_1.Rand.range(candidates.length);
                        let mutation = lodash_1.default.cloneDeep(candidates[index]);
                        extr = Object.assign(extr, mutation);
                        extracted = extractor_1._extract(gentype).from(this._sample);
                    }
                }
                // return modified or unmodified sample,
                // or undefined if no sample passed
                return this._sample;
            }
        };
        this._types = types;
        this._sim._parent = this;
    }
    /**
     * @brief sim - function to wrap _sim constructor, for simpler usage
     *
     * @param {Node} sample - sample node provided to constructor
     */
    sim(sample) {
        let invocator = this._sim;
        return new invocator(sample);
    }
    /**
     * @brief using - generate new AST node from a random node
     *
     * @param {Array<Node>} nodes - AST nodes, one will be selected, and a new AST node will be
     * generated by it
     */
    using(nodes) {
        if (nodes.length > 0) {
            if (this._types) {
                let cnodes = extractor_2._type_filter_callback(nodes, this._types);
                const index = rand_1.Rand.range(cnodes.length);
                let sample = cnodes[index];
                return this.sim(sample).using(cnodes);
            }
            else {
                let cnodes = lodash_1.default.cloneDeep(nodes);
                const index = rand_1.Rand.range(cnodes.length);
                let sample = cnodes[index];
                return this.sim(sample).using(cnodes);
            }
        }
        throw RangeError("Empty array of nodes passed.");
    }
}
exports._Genode = _Genode;
/**
 * @brief init - returns a new @a _Genode object
 *
 * @param {Array<string> | string} types - types parameter will be provided, to the new object
 */
function _initGenode(types) {
    return new _Genode(types);
}
exports._initGenode = _initGenode;
